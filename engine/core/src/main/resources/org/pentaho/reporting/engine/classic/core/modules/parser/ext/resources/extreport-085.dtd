<!--
  Report DTD for JFreeReport version 0.8.5

  Use this as document type definition:

  <!DOCTYPE report-definition
      PUBLIC "-//JFreeReport//DTD report definition//EN//extended/version 0.8.5"
             "http://jfreereport.sourceforge.net/extreport-085.dtd">

  ChangeLog:
    11-Feb-2003 : Initial version
    05-Mar-2003 : Documentation
    20-May-2003 : Bug-Fix
    03-Feb-2005 : Removed the 'datadefinition' stuff - it was never and will
                  never be used.
    27-Jun-2006 ; DataFactory support

-->

    <!--

      The valid page orientations when defining a report page format.

     -->
    <!ENTITY % orientations
        "portrait | landscape | reverse_landscape"
        >

    <!--

      The predefined page formats. This is a list of all page formats defined in
      the class org.pentaho.reporting.engine.classic.core.util.PageFormatFactory.

    -->
    <!ENTITY % pageFormats
        "(  PAPER10X11 | PAPER10X13 | PAPER10X14 | PAPER12X11 | PAPER15X11 | PAPER7X9 | PAPER8X10 |
    PAPER9X11 | PAPER9X12 | A0 | A1 | A2 | A3 | A3_TRANSVERSE | A3_EXTRA | A3_EXTRATRANSVERSE |
    A3_ROTATED | A4 | A4_TRANSVERSE | A4_EXTRA | A4_PLUS | A4_ROTATED | A4_SMALL | A5 |
    A5_TRANSVERSE | A5_EXTRA | A5_ROTATED | A6 | A6_ROTATED | A7 | A8 | A9 | A10 |
    ANSIC | ANSID | ANSIE | ARCHA | ARCHB | ARCHC | ARCHD | ARCHE | B0 | B1 | B2 | B3 | B4 |
    B4_ROTATED | B5 | B5_TRANSVERSE | B5_ROTATED | B6 | B6_ROTATED | B7 | B8 | B9 | B10 |
    C4 | C5 | C6 | COMM10 | DL | DOUBLEPOSTCARD | DOUBLEPOSTCARD_ROTATED | ENV9 | ENV10 |
    ENV11 | ENV12 | ENV14 | ENVC0 | ENVC1 | ENVC2 | ENVC3 | ENVC4 | ENVC5 | ENVC6 | ENVC65 | ENVC7 |
    ENVCHOU3 | ENVCHOU3_ROTATED | ENVCHOU4 | ENVCHOU4_ROTATED | ENVDL | ENVINVITE | ENVISOB4 | ENVISOB5 |
    ENVISOB6 | ENVITALIAN | ENVKAKU2 | ENVKAKU2_ROTATED | ENVKAKU3 | ENVKAKU3_ROTATED | ENVMONARCH |
    ENVPERSONAL | ENVPRC1 | ENVPRC1_ROTATED | ENVPRC2 | ENVPRC2_ROTATED | ENVPRC3 | ENVPRC3_ROTATED |
    ENVPRC4 | ENVPRC4_ROTATED | ENVPRC5 | ENVPRC5_ROTATED | ENVPRC6 | ENVPRC6_ROTATED | ENVPRC7 |
    ENVPRC7_ROTATED | ENVPRC8 | ENVPRC8_ROTATED | ENVPRC9 | ENVPRC9_ROTATED | ENVPRC10 | ENVPRC10_ROTATED |
    ENVYOU4 | ENVYOU4_ROTATED | EXECUTIVE | FANFOLDUS | FANFOLDGERMAN | FANFOLDGERMANLEGAL |
    FOLIO | ISOB0 | ISOB1 | ISOB2 | ISOB3 | ISOB4 | ISOB5 | ISOB5_EXTRA | ISOB6 | ISOB7 | ISOB8 | ISOB9 |
    ISOB10 | LEDGER | LEGAL | LEGAL_EXTRA | LETTER | LETTER_TRANSVERSE | LETTER_EXTRA | LETTER_EXTRATRANSVERSE |
    LETTER_PLUS | LETTER_ROTATED | LETTER_SMALL | MONARCH | NOTE | POSTCARD | POSTCARD_ROTATED | PRC16K |
    PRC16K_ROTATED | PRC32K | PRC32K_ROTATED | PRC32K_BIG | PRC32K_BIGROTATED | QUARTO | STATEMENT | SUPERA |
    SUPERB | TABLOID | TABLOIDEXTRA )"
        >

    <!--

      The root element for all extended report definitions. The order of the child elements
      does matter.

     -->
    <!ELEMENT report-definition (parser-config?, report-config?,
        styles?, templates?, report-description?,
        functions?, include?)>
    <!ATTLIST report-definition
        name CDATA   #IMPLIED
        >

    <!ELEMENT include EMPTY>
    <!ATTLIST include
        src            CDATA           #REQUIRED
        >


    <!--

      The parser config is used to configure the available factories for the parser.
      The parser itself does not create any objects, all object creation code is outsourced
      to the factory implementations.

      The parser can handle more than one factory per type.

     -->
    <!ELEMENT parser-config ((element-factory|stylekey-factory|template-factory|object-factory|datasource-factory)*)>

    <!--

      The style key factory is used to defined style keys for element style sheets.
      The style keys consist of various objects.

      There are 2 kinds of style key definitions:

      Basic Style keys:
        - contain a single string defining the value of the style key.

      Compound style keys:
        - contain a compound object, which consists of one or more other objects.

      The stylekey reference documents all known stylekeys of the base distribution.
      The reference can be generated by calling

      org.pentaho.reporting.engine.classic.extensions.ReferenceDocGenerator

     -->
    <!ELEMENT stylekey-factory EMPTY>
    <!ATTLIST stylekey-factory
        class      CDATA   #REQUIRED
        >

    <!--

      The object factory is used to create all data objects for the report definition.
      Objects are described in an

        org.jfree.xml.factory.objects.ObjectDescription

      The system knows BasicObjectDescriptions, for objects, which only have a single
      string property called "value" defined, and compound object descriptions for
      complex objects which can contain other objects.

      The basic object descriptions are mainly used for primitive data objects, like
      Float, String, Long, Int etc.

      A complete reference of all known object types and their defined properties can
      be generated by calling

      org.pentaho.reporting.engine.classic.extensions.ReferenceDocGenerator

     -->
    <!ELEMENT object-factory EMPTY>
    <!ATTLIST object-factory
        class      CDATA   #REQUIRED
        >

    <!--

      The DataSource factory is a specialized ObjectFactory for generating
      org.pentaho.reporting.engine.classic.core.filter.DataSource objects.

      If the data source is a DataFilter, then an other data source can be
      stacked into it, generating a filter chain for simple data conversion.

      An alternative for using DataSources is the template factory. Templates
      define common usecases for DataSources and allow the easy configuration
      of these usecases on a single interface.

      The reference for the defined datasources is included in the Object-Factory
      reference. All DataSource object descriptions of the base distribution are
      defined in the class factory

      org.pentaho.reporting.engine.classic.core.modules.parser.ext.factory.datasource.DefaultDataSourceFactory

     -->
    <!ELEMENT datasource-factory EMPTY>
    <!ATTLIST datasource-factory
        class      CDATA   #REQUIRED
        >

    <!--

      The template factory is used to generate templates. Templates are Facade
      implementations for the data source interface. A template defines a common
      usecase, f.I. a label, and provides a simple beanified interface for that
      usecase, hiding the complexity of the datasource implementation from the
      user.

      The reference for the defined templates is included in the Object-Factory
      reference. All Template object descriptions of the base distribution are
      defined in the class factory

      org.pentaho.reporting.engine.classic.core.modules.parser.ext.factory.templates.TemplateClassFactory

     -->
    <!ELEMENT template-factory EMPTY>
    <!ATTLIST template-factory
        class      CDATA   #REQUIRED
        >

    <!--

      The element factory is used to define elements. Elements are defined
      by specifying their target content type, it is up to the factory to
      choose a suitable implementation.

      At the moment (0.8.5), five element types are defined:

      text/plain        - The org.pentaho.reporting.engine.classic.core.TextElement
      shape/generic     - The org.pentaho.reporting.engine.classic.core.ShapeElement
      image/generic     - The org.pentaho.reporting.engine.classic.core.ImageElement
      drawable/generic  - the org.pentaho.reporting.engine.classic.core.DrawableElement
      X-anchor          - The org.pentaho.reporting.engine.classic.core.AnchorElement

      This list is likely to grow during the next versions.

     -->
    <!ELEMENT element-factory EMPTY>
    <!ATTLIST element-factory
        class      CDATA   #REQUIRED
        >

    <!--

     The report config is used to define the ReportConfiguration properties
     and the default page format for the report.

     -->
    <!ELEMENT report-config (datafactory?,
        (simple-page-definition|page-definition)?, configuration?)>

    <!ELEMENT datafactory   EMPTY>
    <!ATTLIST datafactory
        type     CDATA     #IMPLIED
        query    CDATA     #IMPLIED
        >

    <!--

      This defines the default page format for the report. The page format
      is used for generating and printing the report, unless the user defines
      a different page format.

      When specifying the paper size, either width and height or one of the predefined
      page formats can be defined.

      All values are defined in points (1/72 inch).
     -->
    <!ELEMENT page-definition (page, page*)>

    <!ELEMENT simple-page-definition (page)>
    <!ATTLIST simple-page-definition
        width          CDATA            #IMPLIED
        height         CDATA            #IMPLIED
        >

    <!ELEMENT page EMPTY>
    <!ATTLIST page
        x              CDATA            #IMPLIED
        y              CDATA            #IMPLIED
        width          CDATA            #IMPLIED
        height         CDATA            #IMPLIED
        pageformat     %pageFormats;    #IMPLIED
        orientation    (%orientations;) #IMPLIED
        leftmargin     CDATA            #IMPLIED
        rightmargin    CDATA            #IMPLIED
        topmargin      CDATA            #IMPLIED
        bottommargin   CDATA            #IMPLIED
        >

    <!--

      A list of all report properties that should be set for the report.
      The report properties are defined as strings.

     -->
    <!ELEMENT configuration (property*)>

    <!ELEMENT property (#PCDATA)>
    <!ATTLIST property
        name           CDATA           #REQUIRED
        class          CDATA           #IMPLIED
        >

    <!--

      The styles section can be used to predefine stylesheets, which can
      be applied to the report elements and bands.

      Stylesheets can inherit values from other style sheets, the inherited
      style key definitions can be overridden by own style definitions.

      The order of the styles definition is important. A style sheet cannot
      be referenced, until it is defined, so parent style sheets must be defined
      before their childs.

      A global library of stylesheets can be defined using the 'include' tag.

     -->
    <!ELEMENT styles (style*)>

    <!--

      Defines a single style sheet. If the stylesheet is defined in the styles
      section, defining a name is mandatory, or the style sheet cannot be referenced
      later.

      Stylesheet consist of several style keys, either basic keys or compound keys.
      The valid keys are defined by the StyleKeyFactory, the defined factories must
      contain a description for all used keys, or the report generation will fail.

     -->
    <!ELEMENT style  (extends*, (basic-key|compound-key)*)>
    <!ATTLIST style
        name           CDATA           #IMPLIED
        >

    <!--

      Defines a parent stylesheet for a style sheet definition. The parent is
      provides default values for the style keys and is queried, if the requested
      stylekey is not defined in the stylesheet.

      Assigning parents allows the definition of cascading style sheets and report
      wide style definitions.

      The specified parent style sheet must be defined before it can be referenced.

     -->
    <!ELEMENT extends  EMPTY>
    <!ATTLIST extends
        name          CDATA  #REQUIRED
        >

    <!--

      Defines a compound style key. Such a key contains a compound object inside,
      an object, that needs more than a single property to be configured.

      The class parameter can be used to request the creation of a specific
      subclass of the style key value object type. If you specify an incompatible
      class, you'll get ClassCastExceptions during the parsing process.

      The object factory is used to create the defined object, the specified
      class must be known to the object factories.

     -->
    <!ELEMENT compound-key (basic-object|compound-object)*>
    <!ATTLIST compound-key
        name           CDATA           #IMPLIED
        class          CDATA           #IMPLIED
        >

    <!--

      Defines a basic style key. Such a key contains a basic object inside,
      an object, that just needs a single string property to be configured.

      The class parameter can be used to request the creation of a specific
      subclass of the style key value object type. If you specify an incompatible
      class, you'll get ClassCastExceptions during the parsing process.

      The object factory is used to create the defined object, the specified
      class must be known to the object factories. If the specified object definition
      is no basic object, the object creation will also fail.

     -->
    <!ELEMENT basic-key    (#PCDATA)>
    <!ATTLIST basic-key
        name           CDATA           #IMPLIED
        class          CDATA           #IMPLIED
        >

    <!--

      Creates a compound object. Compound objects are complex object that need
      more than one property to be defined and can contain other objects in
      their properties.

      The defined properties for an object are specified by an object description.
      The object description is registered in a ClassFactory, the class factory is
      then used to lookup the object description and to create the object.

      For a description of the class factories, have a look at the object-factory
      element definition. A reference document can be generated for every object
      factory.

      The class parameter can be used to request the creation of a specific
      subclass of the style key value object type. If you specify an incompatible
      class, you'll get ClassCastExceptions during the parsing process.

      The object factory is used to create the defined object, the specified
      class must be known to the object factories.

     -->
    <!ELEMENT compound-object (basic-object|compound-object)*>
    <!ATTLIST compound-object
        name           CDATA           #REQUIRED
        class          CDATA           #IMPLIED
        >

    <!--

      Creates a basic object. Basic objects are object that just need
      a single property to be defined and cannot contain other objects inside.
      Basic objects are mostly used to define the primitive data objects of
      java.lang, such as Float, Long, String etc.

      The defined properties for an object are specified by an object description.
      The object description is registered in a ClassFactory, the class factory is
      then used to lookup the object description and to create the object.

      For a description of the class factories, have a look at the object-factory
      element definition. A reference document can be generated for every object
      factory.

      The class parameter can be used to request the creation of a specific
      subclass of the style key value object type. If you specify an incompatible
      class, you'll get ClassCastExceptions during the parsing process.

      The object factory is used to create the defined object, the specified
      class must be known to the object factories.

     -->
    <!ELEMENT basic-object    (#PCDATA)>
    <!ATTLIST basic-object
        name           CDATA           #REQUIRED
        class          CDATA           #IMPLIED
        >

    <!--

      The Templates section can be used to define a common set of properties for
      all referenced templates. This works like the inheritance of stylesheet properties,
      but is not dynamic. Once defined, the properties of the parent template are copied
      into the child, parents and child are not connected in any way after the creation
      process is completed.

      External template definitions are not yet supported.
     -->
    <!ELEMENT templates    (template*)>

    <!--

      Defines a template. Templates are common use cases of the datasource interfaces.
      They act as facade to hide the complex composition of datasources from the user.
      Advanced users, who want to control every aspect of the data conversion within
      the filter chain are free to use raw data source and data filters instead.

      The templates define a set of properties for the use cases, these properties can
      be defined using basic or compound objects.

      A reference for the defined properties of the known template implementations of
      JFreeReport can be found in the object-factory reference documents.

     -->
    <!ELEMENT template     (basic-object|compound-object)*>
    <!ATTLIST template
        name           CDATA           #IMPLIED
        references     CDATA           #REQUIRED
        >

    <!--

      The report description defines the visual appearance of the report, the bands
      and elemnts that make up the resulting output.

      A report constists of several elements, which are all optional:

      * reportheader
        printed at the first page

      * reportfooter
        printed on the last page

      * a page header
        Printed before any content is printed to the page.

      * a page footer
        printed, after the last content for the page is printed
        The pagefooter is always positionated at the bottom of a page,
        regardless how much space of the page is filled.

      * one or more group definitions in the "groups" element
        If no groups are defined, a default group is created to contain
        all data elements of the current report.

      * the item band. This is where the data rows are printed.
        If no item band is defined, only printing the items is disabled. All
        calculations are performed regardless of the appearance of the
        item elements.

      All bands can contain either bands or elements.
      Defining page break properties for inner bands or elements has no effect,
      pagebreak-before and pagebreak-after are only used for root level bands.

      Root level bands may not define either datasources or templates.

     -->
    <!ELEMENT report-description
        (report-header?, report-footer?, page-header?, page-footer?,
            watermark?, no-data-band?, groups?, itemband?)>

    <!--

      The reportheader can contain any element or band.

      The "ownpage" attribute of the simple report definition is defined as
      "pagebreak_after_print" attribute.

      -->
    <!ELEMENT report-header   (style?, (band | element)*)>
    <!ATTLIST report-header
        name           CDATA           #IMPLIED
        >

    <!ELEMENT report-footer   (style?, (band | element)*)>
    <!ATTLIST report-footer
        name           CDATA           #IMPLIED
        >

    <!ELEMENT page-header   (style?, (band | element)*)>
    <!ATTLIST page-header
        name           CDATA           #IMPLIED
        >

    <!ELEMENT page-footer   (style?, (band | element)*)>
    <!ATTLIST page-footer
        name           CDATA           #IMPLIED
        >

    <!ELEMENT watermark   (style?, (band | element)*)>
    <!ATTLIST watermark
        name           CDATA           #IMPLIED
        >

    <!ELEMENT itemband   (style?, (band | element)*)>
    <!ATTLIST itemband
        name           CDATA           #IMPLIED
        >

    <!--

      The tag encapsulates all groups. This tag helps to keep parsing
      simple. If no groups are defined, a default group is created and
      contains all elements of the report datarow

      -->
    <!ELEMENT groups     (group*)>

    <!--

      Defines a group. The fields element is required, as it defines the
      group fields and therefore the position of the group within the group list.

     -->
    <!ELEMENT group      (fields, group-header?, group-footer?)>
    <!ATTLIST group
        name           CDATA           #IMPLIED
        >

    <!--

      the name of the elements that have to change for
      a group break.

      A report group may have more than one group element.
      A group element may only contain Strings defining the
      names of the items which form a group. This is not
      limited to items from the data model, you may also
      enter functions here.

      If you define a subgroup, then you'll have to include all
      fields of the parent group and at least one new field.

     -->
    <!ELEMENT fields     (field*)>
    <!ELEMENT field      (#PCDATA)>

    <!--

      A group header is printed before a group starts. A group start
      is invoked when one element in groupelements changes and on the
      start of the report generation.

      If pagebreak is set to true, a page break will be forced before
      the group header is printed.

      If repeat is set to true, this header is repeated after an pagebreak
      if this group is still active and no other groupheader in an subgroup
      has the repeat flag set.

      -->
    <!ELEMENT group-header   (style?, (band | element)*)>
    <!ATTLIST group-header
        name           CDATA           #IMPLIED
        >

    <!ELEMENT group-footer   (style?, (band | element)*)>
    <!ATTLIST group-footer
        name           CDATA           #IMPLIED
        >

    <!ELEMENT band  (style?, (band | element)*)>
    <!ATTLIST band
        name           CDATA           #IMPLIED
        >

    <!--

      Elements are defined and selected by their content type. To create
      a text element, the required content type is "text/plain". ShapeElements
      are created when specifying the content type of "shape/generic".

      Be carefull when defining a relative width and height, unless the parent
      band defines a maximum size, the element will try to consume as much space
      as possible.

      -->
    <!ELEMENT element  (style?, (template | datasource))>
    <!ATTLIST element
        name           CDATA           #IMPLIED
        type           CDATA           #REQUIRED
        >

    <!--

      The data source definition can be used to assign a datasource to the element.
      If the datasource is a DataFilter implementation, then the datasource may contain
      other datasources.

      The datasource type is specified by the "type" attribute. The attribute must be
      defined in the DataSourceFactory. There is no reference manual for that factory
      yet.

     -->
    <!ELEMENT datasource (datasource?,(basic-object|compound-object)*)>
    <!ATTLIST datasource
        type          CDATA            #REQUIRED
        >

    <!--

      Functions are defined in a function library.
      Every referenced function has to be defined in the
      library in order to be loaded and executed correctly.

      -->
    <!ELEMENT functions  (function | expression | property-ref)*>

    <!--

      defines a collection of properties.

     -->
    <!ELEMENT properties  (property*)>

    <!--

      A reference to a report property. This property is predefined here and can be accessed
      like any other datasource. The value defaults to null if no more data is given. The
      encoding parameter defaults to "text", "serialized-base64" is implemented later to
      allow serialized objects as value for the property.

      The class parameter specifies the class of this report property value. The given class
      must have a valid ObjectDescription registered in the ClassFactory.

    -->
    <!ELEMENT property-ref  (#PCDATA)>
    <!ATTLIST property-ref
        name       CDATA   #REQUIRED
        class      CDATA   #IMPLIED
        >

    <!--

      A defined function has a valid implementing class that implement
      the org.pentaho.reporting.engine.classic.core.function.Function interface. Functions have access to the datarow and
      can access other functions or expressions or the datasource. Functions are statefull and maintain
      their state during the report generation. For stateless user defined computations consider using
      an expression instead of functions, as expression are cheaper to compute and maintain when using
      huge reports.

      Function parameters are given by propery elements. For visual
      editing, function must obey to the java-beans rules (use get*/set*
      methods, perhaps provide beaninfo and so on)

      The deplevel attribute can be used to priorize the functions. Functions with an higher depencylevel
      are executed before any function with lower depency levels. Depencylevels lower than 0 are not allowed.
      -->
    <!ELEMENT function   (properties?)>
    <!ATTLIST function
        class      CDATA    #REQUIRED
        name       CDATA    #REQUIRED
        deplevel   CDATA    #IMPLIED
        >


    <!--

      An expression is a stateless user defined function. It can access the datarow and the reportproperties
      to perform its task. Using the datarow an expression has access to the datasource and other functions
      and expressions.

      Expression parameters are given by propery elements. For visual
      editing, Expressions must obey to the java-beans rules (use get*/set*
      methods, perhaps provide beaninfo and so on)

      The deplevel attribute can be used to priorize the functions. Functions with an higher depencylevel
      are executed before any function with lower depency levels. Depencylevels lower than 0 are not allowed.
      -->
    <!ELEMENT expression   (properties?)>
    <!ATTLIST expression
        class      CDATA    #REQUIRED
        name       CDATA    #REQUIRED
        deplevel   CDATA    #IMPLIED
        >
